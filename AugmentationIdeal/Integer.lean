/-
Authors : Gareth Kmet
-/
import AugmentationIdeal.Basic
import Mathlib.GroupTheory.FiniteAbelian

/-!
## AugmentationIdeal.Integer

This file looks at lemmas and proofs about the `AugmentationIdeal` when restricted to the integer ring

This copies for the end of Theorem I.1.9 of the thesis "Calculation of Augmentation Ideals" by John Kmet

## Main definitions

* `AugmentationIdeal.Integers.Quotients.quot_generating_set` states that `(Δ R,G) ^ n ⧸ (Δ R,G) ^ (n+1)` is
  an additive group generated by the set of elements of the form
  `(∏ i : Fin n, MonoidAlgebra.of gᵢ - 1) + (Δ R,G)^(n+1)`.
* `AugmentationIdeal.Integers.Quotients.finiteGenGroup` defines the `AddGroup.FG` instance for
  `(Δ R,G) ^ n ⧸ (Δ R,G) ^ (n+1)` when `G` is finite
* `AugmentationIdeal.Integers.Quotients.quot_finite` states that `(Δ R,G) ^ n ⧸ (Δ R,G) ^ (n+1)` is a finite
  when `G` is finite

## Implementation

This file makes the assumption that `G` is an abelian group.

## Future work

* change `G` to be non-abelian

-/

open BigOperators Classical

variable {G : Type*} [CommGroup G]

namespace AugmentationIdeal.Integers

variable (G)

noncomputable def integerAugmentationIdeal : Ideal (MonoidAlgebra ℤ G) := AugmentationIdeal ℤ G

def integerAugmentationIdeal' : Ideal (MonoidAlgebra ℤ G) := AugmentationIdeal' ℤ G

variable {G}

namespace Quotients

variable (G)
theorem quot_generating_set (n : ℕ) : AddSubgroup.closure
    { QuotientAddGroup.mk (s:=nrpow_addsubgroup_of_npow ℤ G (n+1) 1)
      (⟨∏ i in Finset.attach (Finset.range (n + 1)),(MonoidAlgebra.single (f i) (1:ℤ) - 1), npow_mem.product_of_basis ℤ G n f⟩ : ((Δ ℤ,G) ^ (n+1) : Ideal (MonoidAlgebra ℤ G)))
      | f : (Finset.range (n + 1)) → G} = ⊤ := by
  rw [AddSubgroup.eq_top_iff']
  intro x
  obtain ⟨x,rfl⟩ := QuotientAddGroup.mk_surjective x
  obtain ⟨m, ⟨f, ⟨r, rfl⟩⟩⟩ := npow_mem.linearcomb_prod_basis_subtype₂ ℤ G n x
  rw [AddSubgroup.mem_closure]
  intro K hK
  rw [QuotientAddGroup.mk_sum]
  apply AddSubgroup.sum_mem
  intro i hi
  rw [QuotientAddGroup.mk_zsmul]
  apply AddSubgroup.zsmul_mem
  rw [Set.subset_def] at hK
  apply hK
  simp only [Set.mem_setOf_eq, exists_apply_eq_apply]

instance finiteGenGroup (n : ℕ) [Fintype G] : AddGroup.FG (quotNatOverSucc ℤ G (n+1)) := AddGroup.fg_iff.mpr <| by
  use { QuotientAddGroup.mk (s:=nrpow_addsubgroup_of_npow ℤ G (n+1) 1)
      (⟨∏ i in Finset.attach (Finset.range (n + 1)),(MonoidAlgebra.single (f i) (1:ℤ) - 1), npow_mem.product_of_basis ℤ G n f⟩ : ((Δ ℤ,G) ^ (n+1) : Ideal (MonoidAlgebra ℤ G)))
      | f : (Finset.range (n + 1)) → G}
  exact ⟨quot_generating_set G n, Set.toFinite ..⟩

instance quot_finite (n : ℕ) [Fintype G] : Finite (quotNatOverSucc ℤ G (n+1)) := by
  apply AddCommGroup.finite_of_fg_torsion
  letI : DecidableEq (MonoidAlgebra ℤ G) := Classical.decEq (MonoidAlgebra ℤ G)
  exact @AugmentationIdeal.Quotients.quot_torsion ℤ G _ _ _ n

end Quotients
